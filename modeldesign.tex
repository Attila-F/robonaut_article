\section{Development methods}

\paragraph{Classic software design approach}

In every software development project, a visual sketch of the system is often created in order to aid the design process, and act as a visual guide in the documentation. However, implementing whatever design that was created earlier is not always trivial. The primary and most widespread embedded programming language, the \verb!C! has been designed as a "Professional Programmers Language", and it supports only very basic syntax checks, but nothing ensures that the program will behave as the programmer intended. The designer must choose to take the risks of unexpected errors, or a thorough testing must be conducted in order to ensure the correct and reliable functioning of the system. While the testing of simple systems can be finished quickly, many dangers surface when the the same method is used in a large multi-developer project. Most of the industry have responded to this in scaling up the work force that gave birth to a number of safety standards, internal regulations and coding guidelines\cite{misra}, and led to a huge amount of overhead in human labour on each software development project.

\paragraph{Model Based Design}

As described earlier, the Model based design is based on solving the problems in a more visual environment. During the development, there is  limited connection between the designed software and the real hardware, as many of the solutions can be verified using the simulated model of the system.
In addition, with the use of the correct methods the result is not only the solution for the problem, but an automation that can generate this solution for a given model. This means, that even if significant changes occur in the specifications, only minimal amount of modification is required to the code that formulates the software. This advantage can not be over emphasized, because the final specifications of the system are rarely known, especially in prototype development.
Although this all sounds very good, it has its own limitations as well. Model based design relies on complex tools to do most of the work, and their operation and integration into the existing project is difficult. Often the usefulness is limited by the lack of hardware-support as well.

\section{Development of the software}

% Contributions

For the \textbf{RobonAUT 2014} contest, we used \verb!MATLAB! and \verb!Simulink! to implement the control system and the state machine. We chose the \verb!MathWorks! product family, because \verb!Simulink! has extensive support for model and simulation based development, and allows the generation of generic \verb!C! source code that can be later used on any hardware that is capable of running \verb!FreeRTOS! or any other hard real-time operating systems.

Figure \ref{fig:architecture} depicts the system architecture and stages of deployment. A typical system developed in \verb!MATLAB! can be divided to the following objects.

\begin{enumerate}
\item A \verb!MATLAB! \verb!Script! that defines the system model and computes the simulator and controller parameters.
\item Based on these parameters we can build the simulator and control software in \verb!Simulink! that interact with each other.
\item If the system response in the simulation is correct, the controller is ready for code generation, and field-testing.
\item The generated source code is invoked by the core operating system, the \verb!FreeRTOS! in this case
\item All communication with the hardware in implemented by the Core.
\end{enumerate}

\begin{figure}[!ht]
    \centering
    \includegraphics[width=\linewidth]{img/architecture}
    \caption{System architecture}
    \label{fig:architecture}
\end{figure}

\subsection{Functional description}

During the race, the track is marked by a dark line on light ground. The car follows this line that guides it through certain checkpoints. Between checkpoints, there are obstacles that need to be passed in a specific way. Each obstacle is marked in a unique manner that allows the car to unambiguously determine, based on simple on-board sensors, which function it has to execute in the current segment.

The recommended sensor loadout\cite[sensors] is a number of optoelectronic sensors beneath the front axis or bumper of the car, and a couple of infrared proximity sensors to cover the front and the two sides of the car. Certain teams extended this setup with a camera for image-recognition, a second optosensor array and other methods. We sticked to the basic recommended sensor outfit, and this paper will not consider any other layouts.

\subsection{Building a model}

The first step in model based design is to create a model of the system, based on the functional description and known sensor loadout. To follow the line, the signals of the optical array must be processed and a control system must use this input to keep the car on the track. Let's define the following state variables:

\begin{center}
  \begin{tabular}{| c | p{0.8\linewidth} |}
\hline
    d & Position error: The shortest distance between the center of the front optical array and the center of the track \\ \hline
    $ \delta $ & Angular error: The angle between the centerline of the body and the tangent of the track \\ \hline
    $ \Phi $ & Steering angle: The effective steering angle, according to Ackermann-steering \\
    \hline
    $ \kappa $ & Current curvature of the track ($1/R$) \\ \hline
    x & Line position: the position of the track line along the front optical array \\ \hline
    c & Line speed: derivative of x, the change of the track line position \\ \hline
    v & Car speed: The current speed of the car along the centerline \\
    \hline
  \end{tabular}
\end{center}

Illustrating the system can help to visualize the relationships:

\begin{figure}[!ht]
    \centering
    \includegraphics[width=\linewidth]{img/cartop}
    \caption{System model}
    \label{fig:cartop}
\end{figure}

\paragraph{Formulating the system model}

the first step is to implement the system descriptor script. In the following we'll build a steering controller.

Knowing the dynamical system equations~(\ref{eq:of1}, \ref{eq:of2}), and parameters (L: wheelbase), we can formulate the \textbf{A} (system transition) and \textbf{B} (system update) matrices linearly approximated in the equilibrium $(d = 0; \delta = 0; v = 1)$ ~(\ref{eq:of3}).

\begin{align} 
    \dot{d} &= sin(\delta + \Phi) \cdot v  \label{eq:of1} \\ 
    \dot{\delta} &= \frac{v}{L} \cdot tan(\Phi) + \kappa \label{eq:of2}
\end{align}

% \begin{minipage}{0.45\linewidth}
%     \begin{align} \label{eq:of3}
%         \begin{bmatrix}
%                \dot{d} \\
%                \dot{\delta}
%         \end{bmatrix}
%         =
%         \begin{bmatrix}
%                0 & \delta \cdot v \\
%                0 & 0
%         \end{bmatrix}
%         %\cdot
%         \begin{bmatrix}
%                d \\
%                \delta
%         \end{bmatrix}
%      \end{align}
% \end{minipage}
% \begin{minipage}{0.45\linewidth}
%     \begin{align} \label{eq:of4}
%         \begin{bmatrix}
%                \dot{d} \\
%                \dot{\delta}
%         \end{bmatrix}
%         =
%         \begin{bmatrix}
%            0 & 0 \\
%            \frac{v}{L} & 1
%          \end{bmatrix}
%         %\cdot
%          \begin{bmatrix}
%                \Phi \\
%                \kappa
%         \end{bmatrix}
%      \end{align}
% \end{minipage}

    \begin{align} \label{eq:of3}
        \begin{bmatrix}
               \dot{d} \\
               \dot{\delta}
        \end{bmatrix}
        =
        \begin{bmatrix}
               0 & \delta \cdot v \\
               0 & 0
        \end{bmatrix}
        %\cdot
        \begin{bmatrix}
               d \\
               \delta
        \end{bmatrix}
		+
        \begin{bmatrix}
           0 & 0 \\
           \frac{v}{L} & 1
         \end{bmatrix}
        %\cdot
         \begin{bmatrix}
               \Phi \\
               \kappa
        \end{bmatrix}
     \end{align}

Instead of hard-coding the system matrices into the script, we can apply a different method that is closer to the model based approach, by using the \verb!MATLAB! \verb!Symbolic! \verb!Toolbox!. This package allows the automatic generation of the Jacobi-matrices of the system, so the inputs are narrowed down to the system parameters and nonlinear dynamic equations.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.7\linewidth]{img/symbolic}
    \caption{Symbolic design}
    \label{fig:symbolic}
\end{figure}

Furthermore, this way we can hold on to a lot more information that can later be used to generate a nonlinear state observer, Extended Kalman Filter[appendix?], or Hybrid Linear Controller[appendix?].
     
\begin{minipage}{0.45\linewidth}
    \begin{align}
        A_J =
        \begin{bmatrix}
           \frac{\partial \dot{d}}{\partial d} & \frac{\partial \dot{d}}{\partial \delta} \\
           & \\
           \frac{\partial \dot{\delta}}{\partial d} & \frac{\partial \dot{\delta}}{\partial \delta}
         \end{bmatrix}
     \end{align}
\end{minipage}
\begin{minipage}{0.45\linewidth}
    \begin{align}
        B_J =
         \begin{bmatrix}
               \frac{\partial \dot{d}}{\partial \Phi} \\
               \\
               \frac{\partial \dot{\delta}}{\partial \Phi}
        \end{bmatrix}
     \end{align}
\end{minipage}

\paragraph{Control system}

Once an accurate system model is available, it's possible to formulate a controller. It's relatively easy to implement multiple controllers and compare their effectiveness on the simulated system to determine, which would fit the robot the best.
Already knowing the state-space form of the system, a full-state feedback controller can be formulated quickly to stabilize the system. Using the Ackermann formula, we get the feedback matrix.

If we check the results we can see that the system has been stabilized.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=\linewidth]{img/plot2}
    \caption{Instabil rendszer állapotvisszacsatolt stabilizációja}
    \label{fig:plot2}
\end{figure}

\paragraph{Direct and inverse measurement models}

Unfortunately, a full-state feedback loop can rarely be realized directly, and the controller we have just created would not be able to control the actual system. Certain states can not be observed directly, and can only be estimated by a state observer. Simulating the sensor readings based on the state variables can be done with the \emph{Direct measurement model}, while in order to estimate the states based on the sensor reading we need the \emph{inverse measurement model}.

Knowing the geometrical layout of the car, the expected sensor readings can be simulated using geometrical projection to the optosensor array:

\begin{align}
    x = \frac{d}{\cos(\delta)}
\end{align}

After the direct model has been determined, the inverse model can be formulated as well:

\begin{align}
    \hat{d} &= x \cdot \cos(\delta) \\
    \hat{c} &=\dot{x} \\
    \hat{\delta} &= \arctan \left(\frac{c}{v}\right) - \Phi
\end{align}

The direct model is usually part of the simulation only, however it's possible to proof-check the sensor readings during run-time. This can be especially useful, if we plan to produce the estimated states using sensor fusion. The inverse measurement model is always the first layer of the control loop, while it is rarely found in the simulated environment.

Note: $\delta$ can be directly measured if the robot is equipped with multiple optosensor arrays.

\subsection{Building the simulation environment}

When a sufficient model and controller are available, it is time to build the simulation environment. In case of a simple system, at this point the controller could be implemented directly in \verb!C!, but if the system is more complex, it is better practice to go through with the model based design. To test the behavior of the system, the controller and the simulator must be implemented in \verb!Simulink! as well. Figure \ref{fig:simenvironment} shows the model based development environment. Because the Controller model and the Controller source code are identical, the key is to design a simulator that is deceptively similar to the real system, from the controller's point of view. This is the reason why Direct and Inverse Measurement (msment) models must be designed.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=\linewidth]{img/simenvironment}
    \centering
    \caption{Simulation environment and analogy of deployment}
    \label{fig:simenvironment}
\end{figure}

Although \verb!MATLAB! is a dynamic typing language, it is good practice to fix the data type of the signals, especially if the software is developed for an embedded system. The default signal type is \emph{Double}, but it should be overridden to \emph{Single}, or \emph{Integer} to spare the limited processing capabilities of the system.

\paragraph{Simulator}

The controller that was designed earlier is based on the linear approximation of the system, but the simulator must always represent the full nonlinear system, or the whole model based design effort is pointless. The system can be created with basic \verb!Simulink! blocks. However, exploiting the technique described earlier to generate the Jacobi matrices of the system, we can use this directly to generate a full representation.

Figure \ref{fig:model} shows the simulation of the dynamics designed to test the control system (without inputs). A common programing analogy can describe how a discrete time \verb!Simulink! \verb!Model! works. The \textbf{States} block is the central element of the model, which stores the actual state variables. It is a \emph{Storage unit}, which acts as a variable in this case. It outputs the value of the input of the previous time-step (which can be considered as a single execution of commands in a loop). The \textbf{Direct measurement model} simulates the sensor readings for the given state variables, in the exact same form as the expected inputs from the hardware (e.g. it generates the signal of each individual optosensor and puts them into a vector (same as a 1-dimensional array), just like the signal that would be received from the Core).

Based on the system dynamics and the current value of the state variables, the states of the car can change. For example, a nonzero speed results in a change of traveled distance for the next time-step, even when there are no inputs to the system. The product of the state variables and the system update matrix (\textbf{\underline{\underline{A}}}) results in a vector filled with the new states. In case of a linear system, \textbf{\underline{\underline{A}}} is constant. In case of a nonlinear system however, \textbf{\underline{\underline{A}}} depends on the current states. 

Consider the above example with nonzero speed (\textbf{v}), a straight track, the distance from the track (\textbf{d}) and angular deviation from the track ($\delta$). While the change of \textbf{d} is a linear function of \textbf{v}, it is also a trigonometric function of $\delta$. The resulting function is nonlinear, which means \textbf{\underline{\underline{A}}} is a nonlinear function of $\delta$. 

The Jacobian is a matrix of the first-order partial derivatives of the system\cite{jacobian}. It basically tells the effect of an individual state variable on the system. The summary of these effects result in the full system update.

\begin{align}
J =
 \begin{bmatrix}
  \frac{\partial F_1}{\partial x_1} & \cdots & \frac{\partial F_1}{\partial x_n} \\
  \vdots  & \ddots & \vdots  \\
  \frac{\partial F_n}{\partial x_1} & \cdots & \frac{\partial F_n}{\partial x_n}
 \end{bmatrix}
\end{align}

If the system is linear, the elements of the matrix are constants. If the system in nonlinear, some elements of the matrix are functions of the state variables themselves.

\begin{figure}[!ht]
    \centering
    \includegraphics[width=\linewidth]{img/sys}
    \centering
    \vspace{-30pt}
    \caption{Jacobi-mátrix alapú nemlineáris szimulátor blokkdiagram}
    \label{fig:model}
\end{figure}

The \textbf{Dynamic nonlinear system update matrix A} block contains a simple MATLAB script that builds the current system update matrix based on the Jacobian functions and the current states. Once we possess this, the system update phase can be executed just like in a linear case, with a matrix product. The resulting vector is the new set of state variables.

\subsection{Implementation of the control system}

Az irányítás tetszőlegesen bonyolult lehet, a RobonAUT-hoz készült megoldás 4 fő kritikus (működéshez elengedhetetlen) részre bontható:

\paragraph{Inverz mérési modell}

A korábban vázolt inverz mérési modell megvalósítása, célja a \textbf{visszacsatolt, mérhető állapotok} előállítása a szenzorok jelei alapján, tehát \textbf{priori információk nélkül}. Mivel a verseny során többféle jelre kellett szabályozni (vonaldetektálás, bal/jobb éldetektálás, bal/jobb távolságérzékelő szenzor jele), ezekre mind létre kell hozni az inverz mérési modellt, majd a megfelelő visszacsatolt állapotot adni tovább a jelfeldolgozónak.

\paragraph{Jelfeldolgozó és állapotbecslő}

Az inverz mérési modell által előállított \textbf{visszacsatolt állapotokat} dolgozza fel \textbf{priori információk} segítségével. Ez a mi esetünkben egy Kálmán-szűrőt jelentett, ahol a mérési jel a visszacsatolt állapot, a priori információ pedig a rendszer modellje. Bár a Kálmán-szűrő támogatja az inverz mérési modell közvetlen integrálását a szűrőbe, ezt a megoldást nem találtam célszerűnek, mivel a szenzorsor jelvektorából a vonal pozíciójele nem állítható elő zárt mátrixos alakban, valamint többféle jelentősen eltérő lehetséges bemenet között kell kapcsolni.

\paragraph{Szabályzó}

A szabályzó a szkript alapján számított paraméterek alapján implementálható, ez függ a választott szabályzó típusától és a tervezés módjától.

\paragraph{Magas szintű irányítás, állapotgép}

A magas szintű irányítás felel a szabályzás és állapotgép alapján történő vezérlés közötti kapcsolásért és a szabályzó bemeneti jelének kiválasztásáért, az aktuális állapot szerint. Ezenkívül referenciajeleket határozhat meg a sebességnek és a kormányszabályzónak.

\subsection{Preparing MATLAB Coder for code generation}

Az elkészült szabályzóból \verb!C! (vagy \verb!C++!, \verb!Verilog! és \verb!PLC!) kódot generálhatunk, melyet beágyazhatunk a rendszerbe. A generált kód egyfajta statikus osztályként működik, vannak belső tárolói és tagfüggvényei, de nem szükséges a példányosítása.

Az első lépés a kódgenerálás előkészítéséhez a megfelelő \textbf{solver} beálítása. Ezt a \textbf{Simulation/Configuration parameters... (Ctrl + E)} menüpontban tehetjük meg a \textbf{Solver} menüpontban. A típust Fixed-step-re kell állítani, a solvert pedig discrete-re, hogy ne legyenek folytonos állapotok a modellünkben. Ezután ne felejtsük el megadni a mintavételi idejét a rendszernek, másodpercben.
Ezt a beállítást célszerű már a modell létrehozásakor, a legelső lépésként elvégezni, ugyanis egy folytonos környezetben épített modell nem feltétlenül fog működni diszkrét solverrel! (Alternatív módon \textbf{Atomic Subsystem} blokkba helyezhetjük a fordítani kívánt rendszert, amennyiben mindenképpen folytonos idejű szimulátorral szeretnénk dolgozni. Ekkor nem szükséges a solver módosítása, viszont gondoskodni kell a mintavételi idő váltásról.)

A tényleges kódgeneráláshoz szükség van egy MATLAB által támogatott \verb!C/C++! compilerre is. A teljes lista megtekinthető a MathWorks weboldalán.\footnote{http://www.mathworks.com/support/compilers/}

\paragraph{Target beállítása}

A kódgenerálásra millióféle különböző beállítás létezik, ezek közül az STM32F4-Discovery kártyához tartozót mutatjuk be, mivel ez volt a célplatform a RobonAUT verseny során.

A \textbf{Hardware Implementation} menüpontban a \textbf{Device Vendor} legördülő listát állítsuk \textbf{ARM Compatible}-re, a \textbf{Device type}-ot pedig \textbf{ARM Cortex}-re.
A \textbf{Code Generation} menüpontban állítsuk át a \textbf{System target file}-t \textbf{ert.tlc}-re (ezzel az általános MATLAB-Embedded codert hívjuk meg).
Az \textbf{Interface} menüpontban a \textbf{Code Replacement Library}-t állítsuk \textbf{GCC ARM Cortex-M3}-re.
Amennyiben lebegőpontos számábrázolást is használunk a programban, kapcsoljuk be ezeknek a támogatását. Kihasználatlanul viszont nem javasolt mindent bekapcsolni, mivel csak felesleges típusdefiníciók jönnek létre. Ha valamit elfelejtettünk beállítani, Build közben hibajelzéssel ide fog visszairányítani a MATLAB.
A \textbf{Report} menüpontban bekapcsolható a "Create code generation report", ami egy dokumentációt is generál a kód mellé.
A \textbf{Code Generation} menüponthoz visszatérve bekapcsolhatjuk az optimalizációkat is, így javíthatunk a kód futásteljesítményén, valamint a generálás sebességén növelhetjük, ha nem kérünk make-filet, illetve buildet egyből, hanem csak a kódot állítjuk elő (úgyis csak arra van szükségünk itt).
A kezelhetőséget javítja, ha a \textbf{Code placement}-ben a \textbf{Code packaging}-et \textbf{Compact}-ra állítjuk, így kevesebb forrásfájlt generál, és könnyebb kezelni, ha csak egy generált rendszerünk van.

\paragraph{Tl;dr}

\begin{itemize}

    \item \textbf{Solver} $\rightarrow$ Fixed step, discrete
    \item \textbf{Hardware Implementation} $\rightarrow$ Device type $\rightarrow$ ARM Cortex
    \item \textbf{Code Generation} $\rightarrow$ System Target File $\rightarrow$ ert.tlc
    \item \textbf{Interface} $\rightarrow$ Code Replacement Library $\rightarrow$ GCC ARM Cortex-M3
    \item \textbf{MATLAB Command Line} $\rightarrow$ \textbf{mex -setup}

\end{itemize}

A megfelelő beállítás után a Simulink modellben keressük meg azt a blokkot, melyből kódot szeretnénk generálni. Egy nagy rendszerben akár több részben is lehet kódot generálni, pl. kapcsolható működés, vagy eltérő mintavételi idő esetén hasznos. Jelen esetben az Irányító rendszer blokkját szeretnénk felhasználni, melynek bemenete a szenzoroktól kapott közvetlen jel, kimenete pedig a szervójel. A blokkon jobb kattintás, majd \textbf{C/C++ Code} $\rightarrow$ \textbf{Build This Subsystem} (Régebbi MATLAB verziókban MATLAB Coder, illetve Real Time Workshop (RTW) menüpontokat kell keresni). A generált fileok a \verb!MATLAB Current Working Folder!-be kerülnek, nem a modell mappájába.









